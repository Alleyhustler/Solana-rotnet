<!DOCTYPE html><!--┴─┬─┴─┤ᴥ•ʔ ├─┬─┴─┬─┴--><html lang=en>
<!-- Mirrored from ve3zsh.neocities.org/blog/2021/11/18/10_years_as_a_career_programmer by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 20 May 2025 11:00:25 GMT -->
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#073642"><link rel=canonical href=https://ve3zsh.ca/blog/2021/11/18/10_years_as_a_career_programmer.html><link rel=icon href=../../../../favicon.ico sizes=16x16><link rel=icon href=../../../../favicon.svg type=image/svg+xml><link rel=stylesheet href=../../../../core.css><link rel=stylesheet href=../../../../print.css media=print><script src=https://ve3zsh.neocities.org/api.js defer></script><script src=../../../../core.js defer></script><link rel=alternate href=../../../index.xml type=application/rss+xml><link rel=preload href=../../../../code.woff2 as=font type=font/woff2 crossorigin><script src=../../../../tag/egg.js defer></script><title>10 Years as a Career Programmer</title>
<meta name=author content="Keller"><meta name=description content="Reflections on my last first 10 years as a professional software developer."><header id=top class=no-print><a id=logo href=../../../../index.html><img src=../../../../img/logo.png alt=VE3ZSH height=35 width=120></a><div class=spacer></div><nav id=menu><span class=no-css>Menu:</span>
<a href=../../../../index.html class=menu-item><img src=../../../../img/icons/projects.svg alt decoding=async height=0 width=0>Projects</a> <span class=no-css>|</span>
<a href=../../../index.html class=menu-item><img src=../../../../img/icons/writings.svg alt decoding=async height=0 width=0>Writings</a> <span class=no-css>|</span>
<a href=../../../../links/index.html class=menu-item><img src=../../../../img/icons/links.svg alt decoding=async height=0 width=0>Links</a> <span class=no-css>|</span>
<a href=../../../../contact/index.html class=menu-item><img src=../../../../img/icons/contact.svg alt decoding=async height=0 width=0>Contact</a></nav></header><hr class=no-css><main><article><h1>10 Years as a Career Programmer</h1><p>This month marks my 10 year anniversary taking this hobby pro. If you've never read Peter Norvig's
essay, <a href=https://www.norvig.com/21-days.html>Teach Yourself Programming in Ten Years</a>,
you really should. It's a piece I read a long time ago that, while lacking a lot of immediate
advice, definitely rings true now that I'm here.<h2><a id=how-it-all-started href=#how-it-all-started>How it All Started</a></h2><p>While this marks 10 years being paid to program, I've been programming since I was roughly 7. My
first programs were hilariously bad. I started on an old
<abbr title="International Business Machines">IBM</abbr> <abbr title="Personal Computer">PC</abbr>
clone running <abbr title=Microsoft>MS</abbr>-<abbr title="Disk Operating System">DOS</abbr> 5.0
where I first learned how to program in Batch scripts.<p>After learning a program called TheDraw and a utility called Batchman, I had the brilliant idea to
write a program that would, when you press a key, display a list of words from the dictionary. It's
no surprise I got as far as copy pasting 26 <code>IF ERRORLEVEL 30 GOTO A</code> lines and typing a
few dozen words from a dictionary split between A and B into TheDraw before I got bored. Hey, it
technically worked. Kind of funny how, to this day, I notice the tendency for programmers to code in
such a way to make solving the actual problem someone else's responsibility.<p>Since then I've learned about a dozen languages, written thousands of lines of software for fun and
for profit, and both learned and forgotten many things about what a computer is and what it can do.
Professionally I've worked as a <abbr title="Database Administrator">DBA</abbr>,
<abbr title="Information Technology">IT</abbr> admin, scientific computing dev, security researcher,
instructor, information research scientist, <abbr title="Machine Leaning">ML</abbr> dev, and now I'm
doing some web full stack.<h2><a id=so-what-would-you-tell-yourself href=#so-what-would-you-tell-yourself>So, What Would You Tell Yourself?</a></h2><p>The question everyone always wants to know, "What would you tell yourself if you could go back in
time?" Let's be honest, I was told a lot of things that I still only barely understand. None of the
advice I can give is much better than advice already out there. The big problem you have is that
there's a lot of counterproductive advice. I think the best advice I can point to comes from that
essay though,
<q cite=https://www.norvig.com/21-days.html>Have the good sense to get off the language standardization effort as quickly as possible.</q><p>It's advice I never really understood when I first read it. I mean, I'd never been a part of this
language standardization effort. But at this point, yeah, Norvig's more right than younger me could
ever imagine, in many more ways than that simple sentence conveys.<h2><a id=programming-and-evidence href=#programming-and-evidence>Programming and Evidence</a></h2><p>See, there's a large contingent of people you'll learn from and interact with as an aspiring
programmer that preach a set of beliefs that you'll come to learn we actually have no real evidence
for. Not only that, but some of their advice we actually <em>do</em> have data on. Data that shows
they're wrong (trust me, they won't let that convince them). This isn't just a programmer problem,
all humans are gullible to rhetoric.<p>So how are you to know who to trust for advice? Well, everyone and nobody. Learn as much as you can.
It's better to be ignorant than only know a little. So always know a lot. If you can't explain
succinctly how something really works (not just by metaphor or abstraction), you probably don't
understand it but you can totally fix that. When someone says something is bad or can't/shouldn't be
done, see what people who disagree with them have to say.<p>Just beware the statement, "You need to do X if you ever want a job as a <em>real</em> programmer."
They're completely wrong. If they don't have data and a methodology to collecting and analyzing it,
they're probably wrong or at least grossly over stating its impact. This is why we invented science.
Rhetoric's greatest enemy is data. Data is not infallible mind you, but a lack of it is often a
worrying sign. If they're right, why not collect some data on that claim?<p>Likewise when you read or hear "always" or "never," these people are also wrong. Don't ignore them,
but try to find someone that disagrees with them and learn why. Everything in real life is
situational and relative.<p>Honestly, the only skills that matter are;<ol><li>a profound curiosity,<li>a high tolerance for ambiguity,<li>a desire to do more with less, and<li>the ability to solve problems.</ol><h2><a id=aesthetics href=#aesthetics>Aesthetics</a></h2><p>What you'll learn Norvig's talking about is every programmer's constant obsession with aesthetic
taste. There's a lot of people who'll tell you without evidence that something will improve your
code by some immeasurable degree. They'll use vague metaphors like technical debt, code smells, code
cleanliness, and more. They'll champion buzzwords like big data, machine learning, software defined
networks, service oriented architecture, agile, magic numbers, expert systems, concurrency, zero
trust, blockchain, data mesh, test driven development, object orientation, story cards, pair
programming, continuous delivery, open offices, 360 feedback, class factories, consensus management,
flexible storage, domain driven design, dynamic programming, ontologies, delayering, layered
architectures, innovation, and <abbr title="You Aren't Gonna Need It">YAGNI</abbr>'s
<abbr title="Single Responsibility, Open Closed, Liskov Substitution, Interface Segregation, Dependency Inversion">SOLID</abbr>
<abbr title="Don't Repeat Yourself">DRY</abbr> <abbr title="Keep It Simple Stupid">KISS</abbr> of
<abbr title="Objective, Key Result">OKR</abbr>s… <abbr title="Oh My God">OMG</abbr>!<p>It's not that none of these work (I mean some of them might and others definitely don't), but rarely
if ever does the person talking about them have any serious data about their efficacy. No, "Here's a
double blind randomized control trial proving this improves metric X across a wide range of people,
places, and situations." Instead they use vague jargon, anecdotes, metaphors, their own and other's
authority along with a good heap of fear, uncertainty, and doubt. The hard part's that disproving
their claims takes real effort. Effort they're not going to put in here. They just want you to use
their product, pay for their courses, read their ad infested blog, or just do things their way
because that's the way they like it.<p>Meanwhile the real problems, the ones your user is relying on you to solve, become an afterthought.
The metrics that really matter to them get forgotten in favour of doing the things that this person
pinky promises matters. If only you did thing X, you would be successful for some abstract measure
of success. Did X and it didn't work? You're probably not doing it right. If only you did it your
code would be simpler for some undefined notion of simple.<p>Measure simple. Then we can easily see if your thing actually increases/decreases that number. Does
that measure even matter? Is it correlated with something we actually care about? Do you have proof
of that? Have you ever thought about what really matters?<h2><a id=what-really-matters href=#what-really-matters>What Really Matters</a></h2><p>For me, minimizing the time I spend reading, writing, modifying, debugging, running, and discussing
code matters. The less of each required, the more time I can spend problem solving. Unfortunately I
don't really know what matters to you. You're going to need to look into that.<p>I'd suggest learning philosophy. Yeah, liberal arts. I strongly recommend it. Too much programming
makes you think you understand everything too much. Sure, 2 + 2 = 4 and a circle's circumference is
proportional to π radians times its diameter. But tell me, is beauty objective or subjective? What
even is beauty? What does that say about your coding standards? Heck, why do you work? Why do we
create art? What is truth?<p>You're not going to find definite answers in philosophy. You're not going to find definite answers
in society. This isn't a coincidence. In physics, each new theory seeks to supersede the previous.
In philosophy each new school seeks to recontextualize what matters. Plus, it'll stop people from
asking you if you can fix their computer at parties.<p>Overall, just relax and make sure you never <em>ever</em> let working rob you of the joy programming
first brought you. I mean it! Sure, if you're in this just for the career, yeah; specialize, build
your network, engage in self promotion, and most importantly spend time practising. If you want to
have fun though, that's gotta be on you. On the bright side, this field seems to be full of people
who appreciate working with others who know a lot about how computers and everything else works. So
for the love of learning, never stop.</article></main>